# Java_JVM

## JIT 运行方式
>JVM有两种运行模式-server -client

区别
- server VM:初始堆空间大些, 默认使用并行垃圾回收器, 启动慢运行快
- client VM:初始堆空间小写, 默认使用串行垃圾回收器, 启动快运行满
- 64位系统:只有server模式

## JVM 架构

### class文件介绍

#### class文件里存了什么数据
>xxx-数字 数字表示的字节数
> <br>命令：javap -v [class]

魔数-4|副版本号-2|主版本号-2|
常量池计数器-2|常量池数据区-n|
访问标志-2|类索引-2|父类索引-2|
接口计数器-2|接口信息数据区-n|
字段计数器-2|字段信息数据区-n|
方法计数器-2|方法信息数据区-n|
属性计数器-2|属性信息数据区-n|

#### class常量池
> cp_info: 常量池项
> 
> constant_pool_count: 常量池计数器
> 
> 常量池计数器是从 **1** 开始计数, 而不是从0开始的, 如果constant_pool_count=22
> 则后面的常量池项(cp_info)的个数是21 （第0项常量空出来单独考虑，为满足某些指向常量池的索引值的数据在待定的情况下表达不引用任何一个常量池项的意思）

##### cp_info结构

     cp_info {
 
       u1    tag;
 
       u1    info[];
 
     }
> tag - 1个字节<br>info[] - 1个字节组成的数组

###### tag
> 1-6属于字面量结构体, 剩余是引用型结构体
> <br>字面量结构体：一个cp_info表示，info[]里存储的是字面量值
> <br>引用型结构体：两个cp_info表示，一个cp_info表示引用类型，一个cp_info表示utf8_info

| Tag值 | 表示的字面量 | 更细化的结构 |
| :---- | :---- | :---- |
| 1 | 字符串常量 | CONSTANT_Utf8_info |
| 3 | 4字节int | CONSTANT_Integer_info |
| 4 | 4字节float | CONSTANT_Float_info |
| 5 | 8字节long | CONSTANT_Long_info |
| 6 | 8字节double | CONSTANT_Double_info |
| 7 | 类或接口全限定名 | CONSTANT_Class_info |
| 8 | String类型 | CONSTANT_String_info |
| 9 | 类中的字段 | CONSTANT_Fieldref_info |
| 10 | 类中的方法 | CONSTANT_Methodref_info |
| 11 | 类所实现的接口的方法 | CONSTANT_InterfaceMethodref_info |
| 12 | 字段或方法的名称和类型 | CONSTANT_NameAndType_info |
| 15 | 方法句柄 | CONSTANT_MethodHandle_info |
| 16 | 方法类型 | CONSTANT_MethodType_info |
| 18 | invokedynamic指令所使用<br>到的引导方法、引导方法<br>使用到动态调用名称、参数<br>和请求返回类型等 | CONSTANT_InvokeDynamic_info |

###### 示例

1. tag 为1-6 
    ```
    cp_info {
      u1 tag=1;
      un info=[xxx];
    }
    ```
2. tag 为7-18
    ```
    cp_info1 {
     u1 tag=7
     u1 info=[cp_info2索引]
    }
    cp_info2 {
     u1 tag=1;
     un info=[xxx];
    }
    ```

##### long和double在常量池中是如何存储的
```
long_cp_info {
  u1 tag=5;
  u4 high_bytes;
  u4 low_bytes;
}

double_cp_info {
  u1 tag=6;
  u4 high_bytes;
  u4 low_bytes;
}
```
> 由此可知long和double虽然是8个字节，但是在计算机中是分成两个4字节进行存储，分为高4位和低4位（为了在32位和64位系统通用）

引出：long和double在操作的时候是否存在线程安全问题

##### double、float、long不声明final就能在常量池中存在，int不声明final也会存在吗？
[解答](#classInt)


##### String类型的字符串常量在常量池中是怎样存储的？
```
string_cp_info {
  u1 tag=8;
  u2 constant_pool_index;
}
utf8_cp_info {
  u1 tag=1;
  u2 length;
  u1 bytes[length]
}
```

###### 那么，字符串常量是否有长度限制呢？

##### 哪些字面量会进入常量池中
1. final类型的8中基本类型的值
2. <span id="classInt">非final类型（包括static的）的8中基本类型的值，只有double、float、long的值会进入常量池</span>
3. 常量池中包含的字符串类型字面量（双引号引起来的字符串值）


#### class中的符号引用和直接引用

##### 符号引用
> 以一组符号来描述所引用的目标，符号可以使任何形式的字面量。如"/java/Math"<br>
> 与内存无关

##### 直接引用
> 1. 指向目标的指针
> 2. 相对偏移量
> 3. 一个能间接定位到目标的句柄

##### 引用替换的时机

> 类加载过程(加载 -> 连接(验证、准备、解析) -> 初始化中的解析阶段

#### class中的特殊字符串
1. 类的全限定名
2. 字段和方法的描述符
3. 特俗方法的方法名

##### 类的全限定名

> 在java文件中是java.lang.Object<br>
> 在class文件中是java/lang/Object

##### 描述符
> 1. 类型描述符
> 2. 字段描述符
> 3. 方法描述符

###### 字段类型描述符

| 数据类型 | 描述符 |
| :---- | :---- |
| byte | B |
| char | C |
| double | D |
| float | F |
| int | I |
| long | J |
| short | S |
| boolean | Z |
| 特殊类型void | V |
| 对象类型 | L + 类的全限定名 + ; 如：Ljava/lang/String;|
| 数组类型 | 若干个[ + 数组中元素类型对应的字符串 如 String[][] -> [[Ljava/lang/String;|

###### 方法描述符

| 方法描述符 | 方发声明 |
| :---- | :---- |
| ()I | int getSize() |
| ()Ljava/lang/String; | String toString() |
| ([Ljava/lang/String;)V | void main(String[] args) |
| ()V | void wait() |
| (JI)V | void wait(long timeout, int nanos) |
| (ZILjava/lang/String;TT)Z | boolean test(boolean a, int b, String c int d, int e) |
| ([BII)I | int test(byte[] b, int a, int c) |
| ()[[Ljava/lang/Object; | Object[][] test() |

###### 特殊方法的方法名
> 类的构造方法和类型初始化方法<br>
> 构造方法 <init><br>
> 静态初始化方法 <clinit>

#### javap命令

> 直接javap -help搜索呗

### 类加载

#### 类加载时机

> 1. new（实例化对象）、get static（读取类静态字段）、put static（设置类静态字段）和invoke static（调用类静态方法）
> 2. java.lang.reflect 反射调用
> 3. 初始化一个类的时候发现其父类没初始化，先初始化父类
> 4. 当虚拟机启动时，用户需要指定一个主类，虚拟机会先执行主类的初始化


#### 类加载过程

> 加载 -> 连接(验证 -> 准备 -> 解析) -> 初始化 -> 使用 -> 卸载

##### 加载(class文件->class对象)

> 将class文件加载到内存<br>
> 1. 通过类的全限定名获取该类的二进制字节流
> 2. 将该字节流的静态存储结构转化为方法区的运行时数据结构
> 3. 在内存中创建该类的java.lang.Class对象，作为方法区该类的各种数据的访问入口

###### 类和数组加载区别

- 非数组类：由类加载器完成
- 数组类：由java虚拟机直接创建

###### 加载过程的注意点

- JVM规范并未给出类在方法区中存放的数据结构
  > 类完成加载后，二进制字节流就以特定的数据结构存储在方法区中，单存储的数据结构是有虚拟机自己定义的，虚拟机规范中并没有指定
- JVM规范并没有指定Class对象存放的位置
  > 在二进制字节流以特定格式存储在方法区后，JVM会创建一个java.lang.Class队形，作为奔雷的外部访问接口<br>
  > 既然是对象就应该存放在Java堆中，不过JVM规范并没有给出限制，不同的虚拟机根据自己的需求存放这个对象
- 加载阶段和连接阶段是交叉的
  > 类加载过程中每个步骤的开始顺序都有严格限制，但是每个步骤的结束顺序没有限制，也就是说类加载过程中由于结束顺序无所谓，每个步骤处理时间长短不一就会导致有些步骤出现交叉
  > <br>HotSport将Class对象存放在方法区

##### 验证(各种检查)

> 比较耗时，虽重要但比一定必要
> <br>可使用`-Xverify:none`参数关闭

###### 目的

> 验证二进制字节流的信息是否符合虚拟机规范，并没有安全问题

###### 过程

1. 格式检查

2. 语义检查

3. 字节码验证

4. 符号引用验证

##### 准备(为static变量分配内存并初始化0值)

> 仅仅为`类变量`(即static修饰的字段变量)分配内存并且该类变量的初始值即零值
> 
> 不包含final修饰的static，因为final在编译的时候就会分配
> 
> 不会为实例变量分配初始化。类变量会分配在方法区中，而实例变量会随着对象一起分配到`堆`中


##### 解析(将符号引用替换为直接引用)

> 主要针对类或接口、字段、类方法、接口方法四类符号引用。分别对应于常量池中的
> 
> `CONSTANT_Class_info`
> 
> `CONSTANT_Fieldref_info`
> 
> `CONSTANT_Methodref_info`
> 
> `CONSTANT_InterfaceMethodref_info`

1. 类或接口解析
   > 判断索要转化成的直接引用是对数组类型还是普通的对象类型的引用，从而进行不同的解析
2. 字段解析
   > 对字段进行解析是，会先在本类中查找是否包含简单名称和字段描述符都和目标相匹配的字段，如果有，则
   > 查找结束，如果没有则会按照继承关系从上到下递归搜索该类所实现的各个接口以及他们的父接口，还没有则按照继承关系从上到下递归搜索
   > 父类。直至查找结束（先接口后类。有的虚拟机更加严格，如果有一个同名字段同时出现类的接口和父类中，或同事在自己或父类的接口中出现，编译器可能会拒绝编译）
3. 类方法解析
   > 对类方法的解析与字段解析搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且
   > 对类方法的匹配搜索是先搜索父类，再搜索接口
4. 接口方法解析
   > 与类方法解析步骤类似，只是接口不会有父类，因此只递归向上搜索父接口就行

##### 初始化(<clinit>方法 类变量)

> 初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码（初始化成为代码设定的
> 默认值）。在准备阶段，类变量已经被赋予过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化
> 类变量和其它资源
> 
> 其实初始化过程就是调用<clinit>类初始化方法的过程，完成对static修饰的类变量的手动赋值还有主动调用静态代码块
> 

- <clinit>方法是编译器自动收集类中所有的赋值动作和静态语句块中的语句合并产生的。编译器收集的顺序是由语句在源文件中出现的顺序所决定
- 静态代码块只能访问到出现在其之前的变量，定义在他之后的变量在其中可以赋值，但是不能访问
   ```java
   public class Test {
        static {
            i = 0;
            System.out.println(i);//编译失败
        }
        static int i = 1;
   } 
   ```
- 实例构造器<init>需要显式调用父类构造函数，而类的<clinit>不需要调用父类的构造函数，虚拟机会确保子类的<clinit>方法执行前已经执行完毕父类的<clinit>方法，因此在JVM中第一个被执行的<clinit>方法的类肯定是`Object`
- 如果一个类\接口中没有静态代码块，也没有静态成员变量的赋值操作，那么编译器就不会为此类生成<clinit>方法

#### 类加载器

> OSGI---复杂的网格方式的热插拔方式的加载

##### 启动类加载器

- 负责加载JAVA_HOME\lib目录中的
- 或通过-Xbootclasspath参数指定路径中的
- 且被虚拟机认可的类
- 由C++实现，不是ClassLoader子类

##### 扩展类加载器

- 负责加载JAVA_HOME\lib\ext目录中的
-或通过java.ext.dirs系统变量指定路径中的类库

##### 应用程序类加载器

- 负责加载用户路径classpath上的类库

##### 自定义加载器




#### 双亲委派模型

> 当类加载的时候，先是由最底层的类加载器去触发加载过程，但是它会先将这个加载委派到它的父加载器
> 。因此最终加载任务都会传递到顶层的启动类加载器
> 
> 好处：不管哪个加载器加载Object类，最终都是委托给顶层的启动器类进行加载
> 这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象
> 

##### JVM搜索类的时候如何判定两个class是相同的？

> 类的全限定名完全相同，但是加载他的类加载器不同，那么在方法区会产生不同的class对象
> 
> JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。

##### 为什么要使用双亲委派模型

> 避免重复加载，当父亲已经加载了该类的时候，就没必要子ClassLoader再加载一次
> 
> 考虑到安全因素，如果不使用这种委派模式，那就可以随时使用自定义的String来动态替换java核心api中定义的类型，会有很大的安全隐患
> ，而双亲委派的方式，就可以避免这种情况。因为String已经在启动时就被引导类加载器加载，所以用户自定义的ClassLoader永远
> 也无法加载一个自己写的String。除非改变JDK中ClassLoader搜索类的默认算法

##### 既然JVM提供了默认的类加载器，为什么还要定义自己的类加载器

> 因为Java中提供的默认ClassLoader只加载指定目录下的jar和class，如果想加载其它位置的类或jar时，就需要自定义
> 
> 如果加载网络上的class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑情况下。默认的类加载器就不能满足需求，所以需要自定义



#### 破坏双亲委派模型

> 双亲委派模型是在JDK1.2以后才使用
> 
> 有些类在JDK1.2之前就已经写好

> 因为在某些情况下，父类加载器需要加载的class文件由于加载范围的限制，父类加载器无法加载到需要的文件，这个时候就需要委托子类加载器进行加载
> 
> 而按照双亲委派模型的话，是子类委托父类加载器去加载class文件，这个时候需要破坏双亲委派模式才能加载成功父类加载器所需要的类。
> 
> 已Driver接口为例，由于Driver接口定义在jdk中，而实现由各个数据库的服务商来提供，这些类都是以jar包的形式放在classpath目录下。
> DriverManager要加载各个实现了Driver接口的实现类并进行管理，但是DriverManager有启动类加载器加载。只能加载java_home\lib下的文件。而起实现由服务商提供，由系统类加载器加载，这时候就需要
> 启动类加载器来委托子类加载Driver实现。就破坏了双亲委派模式

### 运行时数据区

### 执行引擎

## JVM 参数

### 1.标准参数
> 一般稳定，在未来JVM版本中不会改变

```shell
java -help
java -version
```
### 2.-x参数


### 3.-xx参数