# JVM运行时数据区

## JVM运行时数据区概述

### JVM运行时数据区规范

#### 两大类

> 线程独享(不需要垃圾回收)：虚拟机栈、本地方法栈、程序计数器
> 
> 线程共享(垃圾回收)：堆和方 法区

#### 使用顺序

> 线程共享的两块运行时数据区是在JVM启动的时候，就已经按照参数设置进行内存分配了。
> 线程独享的三块运行时数据区不随着JVM启动而分配内存

> JVM启动时
> 
> 先使用`方法区(存类的元信息和静态变量)`:[初始大小、最大大小]. 一般建议初始大小和最大大小设置一样，减少内存自动扩容带来的性能损耗
>
> 堆：初始大小、最大大小（JDK1.7以后 字符串常量池中的字符串对象,程序执行时会产生对象和数组）
> 
> 栈&程序计数器&本地方法栈：和线程有关

### Hotspot运行时数据区

> jdk1.7之前，Hotspot虚拟机对于方法区的实现称之为永久代
> 
> jdk1.8，Hotspot虚拟机对于方法区的实现称之为元空间

> jdk1.6时运行时数据区和字符串常量池在永久代中，1.7时挪到了堆中，1.8时还在堆中，但是永久代变成了元空间

### 分配JVM内存控件

#### 堆的大小

```shell
-Xms(堆的初始容量)
-Xmx(堆的最大容量)
```
#### 方法区的大小

```shell
-XX:PermSize(永久代的初始容量)
-XX:MaxPermSize(永久代的最大容量)
```

```shell
-XX:MetaspaceSize(元空间的初始容量)
-XX:MaxMetaspaceSize(元空间的最大容量,默认没有限制)
```

```shell
# GC相关
-XX:MinMetaspaceFreeRatio(GC后最小的metaspace剩余空间容量的百分比,减少为分配空间所导致的垃圾收集)
-XX:MaxMetaspaceFreeRatio(GC后最大的metaspace剩余空间容量的百分比,减少为分配空间所导致的垃圾收集)
```

```shell
# 分配线程空间的大小
-Xss:
# 为jvm启动的每个线程分配的内存大小，默认jdk1.4是256K，jdk1.5+是1M
```

## 方法区

### 方法区存储内容

```
1.类型信息 如com.woshilll.User类
2.方法信息
3.字段信息
4.方发表(方法调用的时候)在A类的main方法中调用B类的method1方法，是根据B类的方法表去查找合适的方法并进行调用
5.静态变量(类变量)
6.运行时常量池(字符串常量池)---从class中的常量池加载而来
    * 字面量
        * 双引号引起来的字符串值，如"aaa"-会进入字符串常量池
        * final修饰的变量
        * 非final修饰的变量，如long、double、float
    * 符合引用
        * 类的符合引用
        * 方法
        * 字段
```

#### 类型信息

- 类的全限定名
- 超类的全限定名
- 直接超接口的全限定名
- 类型标志(该类是类类型还是接口类型)
- 类的访问描述符(public、private、default、abstract、final、static)

#### 类型的常量池

存放该类型所用到的常量的有序集合，包括直接常量（字符串、整数、浮点数的常量）和对其它类型、字段、方法的符号引用

常量池中每一个保存的常量都有一个索引，就像数组中的字段一样，因为常量池中保存着所有类型使用到的类型、字段、方法的字符引用，所以它也是动态连接的主要对象

#### 字段信息

- 字段修饰符(public、protect、private、default)
- 字段的类型
- 字段名称

#### 方法信息

方法信息中包含类的所有方法，每个方法包含一下信息：
- 方法修饰符
- 方法返回类型
- 方法名
- 方法参数个数、类型、顺序等
- 方法字节码
- 操作数栈和该方法在栈帧中的局部变量区大小
- 异常表